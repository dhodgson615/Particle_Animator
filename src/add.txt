use once_cell::sync::Lazy;
use rayon::prelude::*;
use num_cpus;

static SIM_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    let cpu = num_cpus::get();
    let reserved_for_io = 2; // reserve for ffmpeg + OS
    let sim_threads = (cpu.saturating_sub(reserved_for_io)).max(1);
    rayon::ThreadPoolBuilder::new()
        .num_threads(sim_threads)
        .thread_name(|i| format!("sim-{}", i))
        .build()
        .expect("build sim pool")
});

static RENDER_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    // small pool for encoding/PNG work
    rayon::ThreadPoolBuilder::new()
        .num_threads(2)
        .thread_name(|i| format!("render-{}", i))
        .build()
        .expect("build render pool")
});

// Example: accumulate histogram with par_iter().fold() to avoid atomics
fn accumulate_histogram(particles: &[(f32, f32)], bins: usize) -> Vec<u32> {
    SIM_POOL.install(|| {
        particles
            .par_iter()
            .fold(
                || vec![0u32; bins],
                |mut local_hist, &(x, y)| {
                    // compute bin index (example)
                    let idx = compute_bin_index(x, y, bins);
                    local_hist[idx] = local_hist[idx].saturating_add(1);
                    local_hist
                },
            )
            .reduce(
                || vec![0u32; bins],
                |mut a, b| {
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        *ai = ai.saturating_add(bi);
                    }
                    a
                },
            )
    })
}