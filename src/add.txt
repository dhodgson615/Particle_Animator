// TODO: apply this to main.rs
pub fn compute_histogram_inplace(
    system: &ParticleSystem,
    x_edges: &[f32],
    y_edges: &[f32],
    bins: u32,
    pool: &ThreadPool,
    out: &mut [f32],
) {
    let bins_usize = bins as usize;
    let total_bins = bins_usize * bins_usize;
    let n = system.len();

    let x_min = x_edges[0];
    let x_max = *x_edges.last().unwrap_or(&x_min);
    let y_min = y_edges[0];
    let y_max = *y_edges.last().unwrap_or(&y_min);

    let dx = (x_max - x_min) / bins as f32;
    let dy = (y_max - y_min) / bins as f32;
    let dx_inv = if dx != 0.0 { 1.0 / dx } else { 0.0 };
    let dy_inv = if dy != 0.0 { 1.0 / dy } else { 0.0 };

    for v in out.iter_mut() {
        *v = 0.0;
    }

    let num_threads = pool.current_num_threads();
    let mut locals: Vec<Vec<u32>> = (0..num_threads)
        .map(|_| vec![0u32; total_bins])
        .collect();

    pool.install(|| {
        (0..num_threads).into_par_iter().for_each(|t| {
            let start = (t * n) / num_threads;
            let end = ((t + 1) * n) / num_threads;
            let local = &mut locals[t];

            let x_edges0 = x_min;
            let y_edges0 = y_min;
            let dx_i = dx_inv;
            let dy_i = dy_inv;
            let bins_i = bins as i32;

            for idx in start..end {
                let px = system.x[idx];
                let py = system.y[idx];

                let ix = ((px - x_edges0) * dx_i) as i32;
                let iy = ((py - y_edges0) * dy_i) as i32;

                if ix >= 0 && ix < bins_i && iy >= 0 && iy < bins_i {
                    let id = (iy as usize) * bins_usize + (ix as usize);
                    local[id] = local[id].wrapping_add(1);
                }
            }
        });
    });

    for local in locals.iter() {
        for (i, &c) in local.iter().enumerate() {
            out[i] += c as f32;
        }
    }
}









use once_cell::sync::Lazy;
use rayon::prelude::*;
use num_cpus;

static SIM_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    let cpu = num_cpus::get();
    let reserved_for_io = 2; // reserve for ffmpeg + OS
    let sim_threads = (cpu.saturating_sub(reserved_for_io)).max(1);
    rayon::ThreadPoolBuilder::new()
        .num_threads(sim_threads)
        .thread_name(|i| format!("sim-{}", i))
        .build()
        .expect("build sim pool")
});

static RENDER_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    // small pool for encoding/PNG work
    rayon::ThreadPoolBuilder::new()
        .num_threads(2)
        .thread_name(|i| format!("render-{}", i))
        .build()
        .expect("build render pool")
});

// Example: accumulate histogram with par_iter().fold() to avoid atomics
fn accumulate_histogram(particles: &[(f32, f32)], bins: usize) -> Vec<u32> {
    SIM_POOL.install(|| {
        particles
            .par_iter()
            .fold(
                || vec![0u32; bins],
                |mut local_hist, &(x, y)| {
                    // compute bin index (example)
                    let idx = compute_bin_index(x, y, bins);
                    local_hist[idx] = local_hist[idx].saturating_add(1);
                    local_hist
                },
            )
            .reduce(
                || vec![0u32; bins],
                |mut a, b| {
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        *ai = ai.saturating_add(bi);
                    }
                    a
                },
            )
    })
}

fn compute_bin_index(_x: f32, _y: f32, _bins: usize) -> usize {
    // placeholder: compute correct bin mapping
    0
}
